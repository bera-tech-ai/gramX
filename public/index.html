<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>gramX</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      height: 100vh; overscroll-behavior: none;
    }

    .theme-light { --bg-color:#ffffff; --text-color:#000000; --secondary-bg:#f0f2f5; --border-color:#e0e0e0; }
    .theme-dark  { --bg-color:#1a1a1a; --text-color:#ffffff; --secondary-bg:#2d2d2d; --border-color:#404040; }

    body { background-color: var(--bg-color); color: var(--text-color); }
    .screen { display:none; height:100%; }
    .screen.active { display:block; }
    .connection-status-bar { padding:8px 12px; background:var(--secondary-bg); border-bottom:1px solid var(--border-color); }
    .settings-header { display:flex; align-items:center; justify-content:space-between; padding:12px; border-bottom:1px solid var(--border-color); }
    .back-button { background:none; border:none; font-size:20px; cursor:pointer; color:var(--text-color); }
    .tabs { display:flex; border-bottom:1px solid var(--border-color); }
    .tab { padding:10px 14px; cursor:pointer; }
    .tab.active { border-bottom:2px solid currentColor; font-weight:600; }
    .list { height:calc(100vh - 130px); overflow:auto; }
    .placeholder { padding:14px; opacity:.7; }
    .chat-header { padding:10px 14px; border-bottom:1px solid var(--border-color); }
    .messages { height:calc(100vh - 180px); overflow:auto; padding:12px; }
    .message { margin:8px 0; }
    .message.out { text-align:right; }
    .message .bubble { display:inline-block; padding:8px 10px; border-radius:10px; background:var(--secondary-bg); }
    .message-status-indicator { font-size:12px; opacity:.6; margin-left:6px; }
    .message-input-container { display:flex; gap:8px; padding:10px; border-top:1px solid var(--border-color); background:var(--secondary-bg); }
    .message-input { flex:1; padding:10px; border-radius:8px; border:1px solid var(--border-color); background:var(--bg-color); color:var(--text-color); }
    #emoji-picker { position:absolute; bottom:70px; left:10px; background:var(--bg-color); border:1px solid var(--border-color); border-radius:8px; padding:8px; display:none; max-width:260px; max-height:180px; overflow:auto; }
    #emoji-grid { display:grid; grid-template-columns: repeat(8, 1fr); gap:6px; font-size:18px; }
    #context-menu { position:absolute; display:none; background:var(--bg-color); border:1px solid var(--border-color); border-radius:8px; overflow:hidden; }
    #context-menu button { display:block; width:100%; padding:8px 12px; border:0; text-align:left; background:none; cursor:pointer; }
    #search-container { display:none; padding:8px; border-bottom:1px solid var(--border-color); }
    input, button { color:inherit; }
  </style>
</head>
<body class="theme-light">
  <!-- Connection Status Bar -->
  <div id="connection-status-bar" class="connection-status-bar">
    <span id="connection-status-text">Connecting...</span>
  </div>

  <!-- Simple Auth UI (optional; keep ids used by your JS) -->
  <div id="auth-screen" class="screen active">
    <div style="padding:12px;">
      <h3>Login</h3>
      <div style="margin-top:8px;">
        <input id="login-username" placeholder="username" class="message-input" />
      </div>
      <div style="margin-top:8px;">
        <input id="login-password" placeholder="password" type="password" class="message-input" />
      </div>
      <div style="margin-top:10px;">
        <button onclick="login()">Login</button>
        <button onclick="register()">Register</button>
      </div>
    </div>
  </div>

  <!-- Chat List Screen -->
  <div id="chat-list-screen" class="screen">
    <div class="settings-header">
      <strong>Chats</strong>
      <div>
        <button onclick="openSearch()"><i class="fa fa-search"></i></button>
        <button onclick="openSettings()"><i class="fa fa-gear"></i></button>
      </div>
    </div>

    <div id="search-container">
      <input id="search-input" class="message-input" placeholder="Search..." />
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="conversations" onclick="showTab('conversations')">Conversations</div>
      <div class="tab" data-tab="online" onclick="showTab('online')">Online</div>
    </div>

    <div id="conversations-tab" class="list">
      <div id="no-conversations" class="placeholder">No conversations yet.</div>
    </div>
    <div id="online-tab" class="list" style="display:none;">
      <div id="no-online-users" class="placeholder">No online users.</div>
    </div>
  </div>

  <!-- Private Chat Screen -->
  <div id="private-chat-screen" class="screen">
    <div class="chat-header">
      Chat with <strong id="chat-target-name">—</strong>
    </div>
    <div id="typing-indicator" style="display:none; padding:6px 12px; font-size:12px; opacity:.7;">Typing…</div>
    <div id="private-messages-container" class="messages"></div>
    <div class="message-input-container">
      <button onclick="toggleEmojiPicker()"><i class="fa-regular fa-face-smile"></i></button>
      <input id="private-message-input" class="message-input" placeholder="Type a message" oninput="handleMessageInput()" onkeypress="handlePrivateKeyPress(event)" />
      <button onclick="sendPrivateMessage()"><i class="fa fa-paper-plane"></i></button>
    </div>
  </div>

  <!-- Settings Screen (only once) -->
  <div id="settings-screen" class="screen">
    <div class="settings-header">
      <button class="back-button" onclick="backToChatList()">←</button>
      <span>Settings</span>
      <div style="width:48px;"></div>
    </div>
    <div style="padding:12px;">
      <ul class="settings-list">
        <li class="settings-item" style="padding:10px 0;"><button onclick="changeUsername()">Change Username</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="changeNotifications()">Notifications</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="changePrivacy()">Privacy</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="changeTheme()">Theme</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="showStorage()">Storage</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="manageBlockedUsers()">Blocked Users</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="blockUser()">Block a User</button></li>
        <li class="settings-item" style="padding:10px 0;"><button onclick="logout()">Logout</button></li>
      </ul>
    </div>
  </div>

  <!-- Emoji Picker -->
  <div id="emoji-picker">
    <div id="emoji-grid"></div>
  </div>

  <!-- Context Menu -->
  <div id="context-menu">
    <button onclick="copyMessage()">Copy</button>
    <button onclick="deleteMessage()">Delete</button>
  </div>

  <script>
    // ==================== CONFIGURATION & INITIALIZATION ====================
    let socket = null;
    let currentUser = null;
    let currentTargetUser = null;
    let onlineUsers = [];
    let userConversations = [];
    let isTyping = false;
    let typingTimeout = null;
    let selectedMessage = null;

    // -------- Local Database for offline support --------
    class LocalDB {
      constructor() {
        this.dbName = 'GramXDB';
        this.version = 2;
        this.db = null;
      }
      async init() {
        // minimal stub; replace with IndexedDB as needed
        this.db = { conversations: [] };
        return true;
      }
      async getConversations() {
        return this.db ? this.db.conversations : [];
      }
      async saveConversation(conv) {
        if (!this.db) return;
        const idx = this.db.conversations.findIndex(c => c.id === conv.id);
        if (idx >= 0) this.db.conversations[idx] = conv; else this.db.conversations.push(conv);
      }
    }
    const localDB = new LocalDB();

    // -------- Offline Manager --------
    class OfflineManager {
      constructor() {
        this.isOnline = navigator.onLine;
        this.outbox = [];
        this._bind();
      }
      _bind() {
        window.addEventListener('online', () => {
          this.isOnline = true;
          document.getElementById('connection-status-text').textContent = 'Online';
        });
        window.addEventListener('offline', () => {
          this.isOnline = false;
          document.getElementById('connection-status-text').textContent = 'Offline (messages will send when back online)';
        });
      }
      createMessageElement(message) {
        const div = document.createElement('div');
        div.className = 'message ' + (message.from === currentUser ? 'out' : 'in');
        div.dataset.messageId = message.id || '';
        const bubble = document.createElement('span');
        bubble.className = 'bubble';
        bubble.textContent = message.text || '';
        div.appendChild(bubble);
        const st = document.createElement('span');
        st.className = 'message-status-indicator';
        st.textContent = message.status === 'read' ? '✓✓' : '✓';
        div.appendChild(st);
        div.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          showContextMenu(e, message);
          document.addEventListener('click', hideContextMenu, { once: true });
        });
        return div;
      }
    }
    const offlineManager = new OfflineManager();

    // ==================== UI FUNCTIONS ====================
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
      const el = document.getElementById(screenId);
      if (el) el.classList.add('active');
    }

    function showTab(tabName) {
      // Tabs headers
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      const index = tabName === 'conversations' ? 1 : 2;
      const tabEl = document.querySelector(`.tab:nth-child(${index})`);
      if (tabEl) tabEl.classList.add('active');

      // Tabs content
      const conv = document.getElementById('conversations-tab');
      const onl = document.getElementById('online-tab');
      if (conv && onl) {
        if (tabName === 'conversations') {
          conv.style.display = 'block';
          onl.style.display = 'none';
        } else {
          conv.style.display = 'none';
          onl.style.display = 'block';
          showOnlineUsers();
        }
      }
    }

    function showOnlineUsers() {
      updateOnlineUsersList();
    }

    function openSearch() {
      const box = document.getElementById('search-container');
      if (!box) return;
      box.style.display = box.style.display === 'none' ? 'block' : 'none';
    }

    function toggleEmojiPicker() {
      const picker = document.getElementById('emoji-picker');
      if (!picker) return;
      picker.style.display = picker.style.display === 'none' ? 'block' : 'none';
    }

    function populateEmojiPicker() {
      const emojiGrid = document.getElementById('emoji-grid');
      if (!emojiGrid) return;
      const emojis = ['😀','😃','😄','😁','😆','😅','😂','🤣','😊','😇','🙂','🙃','😉','😌','😍','🥰','😘','😗','😙','😚','😋','😛','😝','😜','🤪','🤨','🧐','🤓','😎','🤩','🥳','😏','😒','😞','😔','😟','😕','🙁','☹️','😣','😖','😫','😩','🥺','😢','😭','😤','😠','😡','🤬','🤯','😳','🥵','🥶','😱','😨','😰','😥','😓','🫣','🤗','🫡','🤔','🫢','🤭','🤫','🤥','😶','🫠','😐','🫤','😑','😬','🙄','😯','😦','😧','😮','😲','🥱','😴','🤤','😪','😵','🫥','🤐','🥴','🤢','🤮','🤧','😷','🤒','🤕','🤑','🤠','😈','👿','👹','👺','🤡','💩','👻','💀','☠️','👽','👾','🤖','🎃','😺','😸','😹','😻','😼','😽','🙀','😿','😾'];
      emojiGrid.innerHTML = '';
      emojis.forEach(e => {
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = e;
        b.style.border = 'none';
        b.style.background = 'none';
        b.style.fontSize = '20px';
        b.style.cursor = 'pointer';
        b.addEventListener('click', () => {
          const input = document.getElementById('private-message-input');
          if (input) {
            input.value += e;
            input.focus();
          }
        });
        emojiGrid.appendChild(b);
      });
    }

    function showContextMenu(e, message) {
      selectedMessage = message;
      const menu = document.getElementById('context-menu');
      if (!menu) return;
      menu.style.display = 'block';
      menu.style.left = e.pageX + 'px';
      menu.style.top = e.pageY + 'px';
    }

    function hideContextMenu() {
      const menu = document.getElementById('context-menu');
      if (menu) menu.style.display = 'none';
      document.removeEventListener('click', hideContextMenu);
    }

    function copyMessage() {
      if (selectedMessage?.text) {
        navigator.clipboard.writeText(selectedMessage.text);
        hideContextMenu();
      }
    }

    function deleteMessage() {
      if (selectedMessage) {
        // Implement deletion logic here (and update UI)
        console.log('Delete message:', selectedMessage);
        hideContextMenu();
      }
    }

    // ==================== AUTHENTICATION ====================
    async function register() {
      const username = document.getElementById('register-username')?.value;
      const password = document.getElementById('register-password')?.value;
      console.log('register()', username, password);
      // TODO: POST /register
    }

    async function login() {
      const username = document.getElementById('login-username')?.value?.trim();
      const password = document.getElementById('login-password')?.value;
      if (!username) return alert('Enter username');
      currentUser = username;
      showScreen('chat-list-screen');
      // Optionally: await initializeSocket();
      await loadLocalConversations();
    }

    // ==================== SOCKET.IO & MESSAGING ====================
    function initializeSocket() {
      // Requires <script src="/socket.io/socket.io.js"></script> served by your backend
      if (typeof io !== 'function') {
        console.warn('socket.io client not found on page; skipping initializeSocket()');
        return;
      }
      socket = io();
      socket.emit('user-login', currentUser);
    }

    async function loadLocalConversations() {
      try {
        const conversations = await localDB.getConversations();
        if (conversations && conversations.length > 0) {
          userConversations = conversations;
        }
        updateConversationsList();
      } catch (error) {
        console.error('Error loading local conversations:', error);
      }
    }

    function updateConversationsList() {
      const container = document.getElementById('conversations-tab');
      const emptyState = document.getElementById('no-conversations');
      if (!container || !emptyState) return;

      container.querySelectorAll('.conversation-item').forEach(n => n.remove());
      if (!userConversations.length) {
        emptyState.style.display = 'block';
        return;
      }
      emptyState.style.display = 'none';

      userConversations.forEach(c => {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        item.style.padding = '10px 12px';
        item.style.borderBottom = '1px solid var(--border-color)';
        item.textContent = c.name || c.id || 'Conversation';
        item.addEventListener('click', () => {
          const target = (c.participants || []).find(u => u !== currentUser) || c.name || 'Unknown';
          startPrivateChat(target);
        });
        container.appendChild(item);
      });
    }

    function updateOnlineUsersList() {
      const container = document.getElementById('online-tab');
      const emptyState = document.getElementById('no-online-users');
      if (!container || !emptyState) return;

      container.querySelectorAll('.user-item').forEach(n => n.remove());
      if (!onlineUsers.length) {
        emptyState.style.display = 'block';
        return;
      }
      emptyState.style.display = 'none';

      onlineUsers.forEach(u => {
        const item = document.createElement('div');
        item.className = 'user-item';
        item.style.padding = '10px 12px';
        item.style.borderBottom = '1px solid var(--border-color)';
        item.textContent = u;
        item.addEventListener('click', () => startPrivateChat(u));
        container.appendChild(item);
      });
    }

    async function startPrivateChat(targetUser) {
      currentTargetUser = targetUser;
      const nameEl = document.getElementById('chat-target-name');
      if (nameEl) nameEl.textContent = targetUser;
      showScreen('private-chat-screen');

      // Load existing messages for this conversation (from local for now)
      const convId = getConversationId(currentUser, currentTargetUser);
      const conv = userConversations.find(c => c.id === convId);
      displayMessages(conv?.messages || []);
    }

    function getConversationId(user1, user2) {
      return [user1, user2].sort().join('_');
    }

    function displayMessages(messages) {
      const container = document.getElementById('private-messages-container');
      if (!container) return;
      container.innerHTML = '';
      messages.forEach(msg => addPrivateMessageToChat(msg));
      container.scrollTop = container.scrollHeight;
    }

    function addPrivateMessageToChat(message) {
      const container = document.getElementById('private-messages-container');
      if (!container) return;
      const messageDiv = offlineManager.createMessageElement(message);
      container.appendChild(messageDiv);
      container.scrollTop = container.scrollHeight;
    }

    function updateMessageStatus(messageId, status) {
      const messages = document.querySelectorAll('.message');
      messages.forEach(msg => {
        if (msg.dataset.messageId === String(messageId)) {
          const statusElement = msg.querySelector('.message-status-indicator');
          if (statusElement) statusElement.textContent = status === 'read' ? '✓✓' : '✓';
        }
      });
    }

    function showTypingIndicator() {
      const indicator = document.getElementById('typing-indicator');
      if (indicator) indicator.style.display = 'block';
    }

    function hideTypingIndicator() {
      const indicator = document.getElementById('typing-indicator');
      if (indicator) indicator.style.display = 'none';
    }

    function handleMessageInput() {
      const input = document.getElementById('private-message-input');
      if (!input) return;
      // debounce typing indicator if needed
    }

    async function sendPrivateMessage() {
      const input = document.getElementById('private-message-input');
      if (!input) return;
      const text = input.value.trim();
      if (!text || !currentUser || !currentTargetUser) return;

      const message = {
        id: String(Date.now()),
        text, from: currentUser, to: currentTargetUser,
        status: 'sent', ts: Date.now()
      };
      addPrivateMessageToChat(message);
      input.value = '';

      // TODO: emit via socket or POST to server
      if (socket && offlineManager.isOnline) {
        // socket.emit('private-message', message);
      } else {
        offlineManager.outbox.push(message);
      }
    }

    function handlePrivateKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendPrivateMessage();
      }
    }

    function backToChatList() {
      showScreen('chat-list-screen');
      if (socket && offlineManager.isOnline) {
        socket.emit('user-login', currentUser);
      }
    }

    // ==================== SETTINGS FUNCTIONS ====================
    async function openSettings() {
      try {
        // Load user settings from server
        const response = await fetch(`/user-settings/${currentUser}`);
        const result = await response.json();
        updateSettingsUI(result?.settings || {});
        showScreen('settings-screen');
      } catch (e) {
        console.error('openSettings failed:', e);
        showScreen('settings-screen');
      }
    }

    function updateSettingsUI(settings) {
      window.userSettings = settings || {};
    }

    async function changeUsername() {
      const newUsername = prompt('Enter new username:');
      if (newUsername && newUsername !== currentUser) {
        try {
          const response = await fetch('/change-username', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ currentUsername: currentUser, newUsername })
          });
          const res = await response.json();
          if (res?.ok) {
            currentUser = newUsername;
            alert('Username changed.');
          } else {
            alert(res?.message || 'Failed to change username.');
          }
        } catch (e) {
          console.error(e);
          alert('Error changing username.');
        }
      }
    }

    async function changeNotifications() {
      const newSetting = !(window.userSettings?.notifications);
      try {
        const res = await fetch('/settings/notifications', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: currentUser, notifications: newSetting })
        });
        const data = await res.json();
        if (data?.ok) {
          window.userSettings.notifications = newSetting;
          alert('Notifications updated.');
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function changePrivacy() {
      const privacyOptions = [
        { value: 'everyone', label: 'Everyone' },
        { value: 'contacts', label: 'My Contacts' },
        { value: 'nobody',   label: 'Nobody' }
      ];
      const choice = prompt('Privacy (everyone / contacts / nobody):', window.userSettings?.privacy || 'everyone');
      const valid = privacyOptions.map(o => o.value);
      if (!choice || !valid.includes(choice)) return;
      try {
        const res = await fetch('/settings/privacy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: currentUser, privacy: choice })
        });
        const data = await res.json();
        if (data?.ok) {
          window.userSettings.privacy = choice;
          alert('Privacy updated.');
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function changeTheme() {
      const themes = ['light', 'dark', 'system'];
      const currentTheme = window.userSettings?.theme || 'light';
      const next = prompt('Theme (light / dark):', currentTheme) || currentTheme;
      const theme = themes.includes(next) ? next : 'light';
      window.userSettings = { ...(window.userSettings || {}), theme };
      applyTheme(theme);
      localStorage.setItem('gramX-theme', theme);
    }

    function applyTheme(theme) {
      document.body.classList.remove('theme-light', 'theme-dark');
      if (theme === 'dark') document.body.classList.add('theme-dark');
      else document.body.classList.add('theme-light');
    }

    async function showStorage() {
      try {
        const estimate = await navigator.storage.estimate();
        const usageMB = (estimate.usage / (1024 * 1024)).toFixed(2);
        const quotaMB = (estimate.quota / (1024 * 1024)).toFixed(2);
        alert(`Storage: ${usageMB} MB of ${quotaMB} MB used`);
      } catch (e) {
        console.error(e);
      }
    }

    async function manageBlockedUsers() {
      try {
        const response = await fetch(`/blocked-users/${currentUser}`);
        const result = await response.json();
        alert(`Blocked users: ${(result?.users || []).join(', ') || 'None'}`);
      } catch (e) {
        console.error(e);
      }
    }

    async function blockUser() {
      const userToBlock = prompt('Enter username to block:');
      if (userToBlock && userToBlock !== currentUser) {
        try {
          const userCheck = await fetch(`/check-user/${userToBlock}`);
          const userResult = await userCheck.json();
          if (!userResult?.exists) return alert('User not found.');
          const res = await fetch('/block-user', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ by: currentUser, target: userToBlock })
          });
          const data = await res.json();
          if (data?.ok) alert('User blocked.');
        } catch (e) {
          console.error(e);
        }
      }
    }

    function logout() {
      currentUser = null;
      currentTargetUser = null;
      onlineUsers = [];
      userConversations = [];
      showScreen('auth-screen');
    }

    // ==================== INITIALIZATION ====================
    async function init() {
      try {
        await localDB.init();
        populateEmojiPicker();

        // Load saved theme
        const savedTheme = localStorage.getItem('gramX-theme') || 'light';
        applyTheme(savedTheme);

        // Prefill for testing if inputs exist
        const u = document.getElementById('login-username');
        const p = document.getElementById('login-password');
        if (u) u.value = 'user1';
        if (p) p.value = 'pass';
      } catch (e) {
        console.error('init failed:', e);
      }
    }

    window.addEventListener('DOMContentLoaded', init);

    // ==================== NOTES FOR BACKEND ROUTES ====================
    // Add these to your server.js (example Express/Mongo):
    //
    // app.get('/check-user/:username', async (req, res) => { /* return {exists:true/false} */ });
    // app.post('/change-username', async (req, res) => { /* rename user; return {ok:true} */ });
    // app.get('/user-settings/:username', async (req, res) => { /* return {settings:{...}} */ });
    // app.get('/blocked-users/:username', async (req, res) => { /* return {users:[...]} */ });
    // app.post('/block-user', async (req, res) => { /* block user; return {ok:true} */ });
  </script>
</body>
</html>
